Name: Grant Schaeffer

Number of elements: 1000

Bubble Sort
Sorted: 0.22769 seconds
Reversed: 0.29428 seconds
Random: 0.15999 seconds

Bubble Sort Early Exit
Sorted: 0.00010 seconds
Reversed: 0.05409 seconds
Random: 0.04392 seconds

Selection Sort
Sorted: 0.02111 seconds
Reversed: 0.01869 seconds
Random: 0.01897 seconds

Insertion Sort
Sorted: 0.00015 seconds
Reversed: 0.03209 seconds
Random: 0.01845 seconds

Merge Sort
Sorted: 0.00121 seconds
Reversed: 0.00117 seconds
Random: 0.00138 seconds

Questions to answer:
1) What was the worst case scenario for any sorting technique?
The bubble sort had the all-around worst times

2) The first 3 sorts have the same runtime of O(n^2). Why were the times different? Why would one be more efficient than the others?
The times differed based on what process the code had to go through to sort the list. The more efficient sorts had less steps.

3) Why was merge sort so much more efficient?
The merge sort was the most efficient because functionally, it starts with half of the range.

4) The built-in sorting technique for most programming languages is known as TimSort.
This is a merge sort until the arrays have fewer than 10 elements, then it does an insertion sort. Why would this be useful?
The merge sort can efficiently cut down the amount of elements, then the insertion sort can efficiently place them.

5) What issues can you see with a recursive sorting technique like merge sort?
If a list were too small or the list had equal repetetive values.